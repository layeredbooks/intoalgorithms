[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Into Algorithms",
    "section": "",
    "text": "Preface\nThis is a book about algorithms. By algorithms, I mean algorithms in the computer science sense, such as algorithms for traversing a graph, computing prime factors of a number, or finding the best path through a maze.\nThe book reflects my experience from learning about algorithms. I have practiced, mostly using Kattis, but also participated in on-line courses and purchased, and partly read, on-line articles and books.\nI did my first Kattis problem in September 2019. Starting from a hello world style problem, I continued, with problems having difficulty level set to easy.\nI was confident that I would succeed. I regarded myself as a programmer, with several years of professional and private experience of software development.\nAfter having tried a few problems with difficulty level set to easy, I moved on to a problem with medium difficulty.\nIt was a problem about a graph, and about figuring out the shortest path to a goal from different places in the graph, and then deciding to take, for a given node, a path that was not a shortest path.\nI made several attempts, and all of them failed.\nI had heard of Dijkstra’s algorithm, but never implemented it myself. I had also heard of Dynamic Programming, and even practised it during my Master thesis work. I had no clue, however, if these two topics had anything in common.\nAfter many tries, and solving many easier problem in between, I solved the problem. This was in August 2020.\nI realized that my confidence about programming was not on par with my skills for solving Kattis problems. I had a long way to go, in order to solve more problems on medium level, and I didn’t even dare to try any problems with difficulty level set to hard.\nI wanted to learn more. I signed up for, and completed, an excellent course series on Data Structures and Algorithms. It was not for free, but it was a very rewarding investment. The teachers were excellent, the lectures were pedagogical, and the labs were challenging.\nI continued with Kattis, and managed to solve also some problems with somewhat higher difficulty level.\nI had an ongoing project where I wanted to make books with layers. The idea was, and still is, to have a book with several layers, with common content, and with content specific for each layer.\nFor a book about programming, it makes sense, I think, to have layers that correspond to programming languages.\nOut of this came the decision to write down some of my experiences of working with algorithms in the context of solving Kattis problems, as a layered book.\nIt is a work in progress, and I will continue to update it, here on GitHub, as time goes on.\nIt is written using Quarto.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "2 Sources of inspiration\nI have already mentioned Kattis, which is where I started by journey into algorithms. In the beginning of that journey I discovered Sannemo (2020), which I think contains very good material about competetive programming. It also contains recommended Kattis problems to solve.\nAnother book about competitive programming is Laaksonen (2020). It contains good material, and it gives a recommendation to use the CSES problem set for practice, while reading the book.\nA pair of books, with The Lower Bound of Programming Contests in the 2020s as their subtitle, and a web page with information about the books, is Halim and Halim (2018) and Halim and Halim (2020).\nAnother resource that I would like to mention is Algorithms for Competitive Programming, with descriptions of many algorithms, and code examples.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#outline",
    "href": "intro.html#outline",
    "title": "1  Introduction",
    "section": "2.1 Outline",
    "text": "2.1 Outline\nWe start of with graphs, in Chapter 2.\n\n\n\n\nHalim, Steven, and Felix Halim. 2018. Competitive Programming 4 - Book 1. https://cpbook.net.\n\n\n———. 2020. Competitive Programming 4 - Book 2. https://cpbook.net.\n\n\nLaaksonen, Antti. 2020. Guide to Competitive Programming - Learning and Improving Algorithms Through Contests. 2nd ed. Springer.\n\n\nSannemo, Johan. 2020. Algorithmic Problem Solving. https://jsannemo.se/aps.pdf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "graphs.html",
    "href": "graphs.html",
    "title": "2  Graphs",
    "section": "",
    "text": "2.1 Notations and Terminology\nA graph is defined by a set of vertices, also referred to as nodes, and a set of edges.\nWe use the notation \\(V\\) for the set of vertices and the notation \\(E\\) for the set of edges.\nA graph \\(g\\) is defined as \\[\ng = (V, E)\n\\]\nAn edge is \\(e\\) is defined by a pair of vertices, as \\[\ne = (v_1, v_2)\n\\] A directed graph is a graph where the vertices in each edge \\(e\\) are interpreted as a ordered pair \\((v_1, v_2)\\), so that the edge starts at \\(v_1\\) and ends at \\(v_2\\).\nAn undirected graph is where the vertices in each edge \\(e\\) do not have any defined order. Their role is to indicate to which vertices the edge is connected, without any connotations of direction.\nA weighted graph is a graph where each edge \\(e\\) is associated with a numeric value \\(w\\), referred to as the weight of the edge.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#graph-traversal",
    "href": "graphs.html#graph-traversal",
    "title": "2  Graphs",
    "section": "2.2 Graph traversal",
    "text": "2.2 Graph traversal\nWe can traverse a graph by starting from a node \\(v_s\\), and then find a way to visit all nodes that can be reached from \\(v_s\\).\nIf the graph is connected, in the sense that all its nodes can be reached from \\(v_s\\), then the graph traversal will visit all the nodes.\nIf the graph is not connected, we can, after the traversal is done, pick a node that is not yet visited. We can start a new traversal from that node. When this is done we can check if all nodes are visited. If this is not the case, we can repeat the process, by picking a new node that is not yet visited and start a new traversal from that node.\nIn the end, we will have visited all nodes.\n\n2.2.1 DFS\nWhen doing a graph traversal, we must, at a given node \\(v\\), determine which node to visit next. Naturally, we must select one of the neighbors of \\(v\\).\nIf we select a neigbor of \\(v\\), and then select one of the neighbors of the selected neigbor, and proceed like this until we come to a node where where there either are no neigbors to select, or we have already visited all neigbors, we get what is known as depth first search, abbreviated as DFS.\nWhile proceeding, we keep track of nodes where we have selected neighbors, and when we are done with a node, we return to the node from which the node we are done with was selectd. We kan keep track of this using a stack.\nIf we implement the DFS as a recursive function, the call stack for this function will serve as such a stack.\nPseudocode for a DFS algorithm is shown in Algorithm 2.1.\n\n\n\\begin{algorithm} \\caption{DFS} \\begin{algorithmic} \\Require a graph and a vector $visited$, with all elements initialized to false \\Procedure{DFS}{$v, visited$} \\State $visited[v] = true$ \\For{$v_{nb}$ \\bfseries{in} $neighbors[v]$} \\If{not $visited[v_{nb}]$} \\State \\Call{DFS}{$v_{nb}, visited$} \\EndIf \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\nAs can be seen on line 3 in Algorithm 2.1, we have a really cool notation for our pseudocode.\n\n\n2.2.2 BFS",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#connectedness",
    "href": "graphs.html#connectedness",
    "title": "2  Graphs",
    "section": "2.3 Connectedness",
    "text": "2.3 Connectedness\n\n2.3.1 Connected components\n\n\n2.3.2 Strongly connected components\n\n\n2.3.3 Topological sort",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#spanning-trees",
    "href": "graphs.html#spanning-trees",
    "title": "2  Graphs",
    "section": "2.4 Spanning Trees",
    "text": "2.4 Spanning Trees",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#paths",
    "href": "graphs.html#paths",
    "title": "2  Graphs",
    "section": "2.5 Paths",
    "text": "2.5 Paths",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#eulerian-graphs",
    "href": "graphs.html#eulerian-graphs",
    "title": "2  Graphs",
    "section": "2.6 Eulerian graphs",
    "text": "2.6 Eulerian graphs",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "graphs.html#bipartite-graphs",
    "href": "graphs.html#bipartite-graphs",
    "title": "2  Graphs",
    "section": "2.7 Bipartite graphs",
    "text": "2.7 Bipartite graphs",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Graphs</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "extra.html",
    "href": "extra.html",
    "title": "4  Extra",
    "section": "",
    "text": "This content will only appear in the advanced version.\n\n#include &lt;vector&gt;\n\ntemplate &lt;typename Graph, bool verbose = false, bool save_path = false&gt;\nclass DFS\n{\n    Graph g;\n    std::vector&lt;int&gt; path;\n\n    void dfs(int v, std::vector&lt;bool&gt; &visited)\n    {\n        if constexpr (verbose)\n        {\n            std::cout &lt;&lt; \"visiting v: \" &lt;&lt; v &lt;&lt; std::endl;\n        }\n        visited[v] = true;\n        if constexpr (save_path)\n        {\n            path.push_back(v);\n        }\n        for (auto v_nb : g.get_nb_vec(v))\n        {\n            if (!visited[v_nb])\n            {\n                dfs(v_nb, visited);\n            }\n        }\n    }\n\npublic:\n    explicit DFS(const Graph &g) : g(g)\n    {\n    }\n\n    void traverse(int v_start)\n    {\n        std::vector&lt;bool&gt; visited(g.get_n_nodes(), false);\n        dfs(v_start, visited);\n    }\n\n    const std::vector&lt;int&gt; &get_path() const\n    {\n        return path;\n    }\n\n    void print_path() const\n    {\n        for (auto v : path)\n        {\n            std::cout &lt;&lt; v &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n};\nok, let’s try something else:\n\n#include &lt;vector&gt;\n\ntemplate &lt;typename Graph, bool verbose = false, bool save_path = false&gt;\nclass DFS\n{\n    Graph g;\n    std::vector&lt;int&gt; path;\n\n    void dfs(int v, std::vector&lt;bool&gt; &visited)\n    {\n        if constexpr (verbose)\n        {\n            std::cout &lt;&lt; \"visiting v: \" &lt;&lt; v &lt;&lt; std::endl;\n        }\n        visited[v] = true;\n        if constexpr (save_path)\n        {\n            path.push_back(v);\n        }\n        for (auto v_nb : g.get_nb_vec(v))\n        {\n            if (!visited[v_nb])\n            {\n                dfs(v_nb, visited);\n            }\n        }\n    }\n\npublic:\n    explicit DFS(const Graph &g) : g(g)\n    {\n    }\n\n    void traverse(int v_start)\n    {\n        std::vector&lt;bool&gt; visited(g.get_n_nodes(), false);\n        dfs(v_start, visited);\n    }\n\n    const std::vector&lt;int&gt; &get_path() const\n    {\n        return path;\n    }\n\n    void print_path() const\n    {\n        for (auto v : path)\n        {\n            std::cout &lt;&lt; v &lt;&lt; \" \";\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n};\n{#lst-code .r lst-cap=“Some R code”}\nLet’s make some pseudo code, as\n\n\n\\begin{algorithm} \\caption{Quicksort} \\begin{algorithmic} \\Procedure{Quicksort}{$A, p, r$} \\If{$p &lt; r$} \\State $q = $ \\Call{Partition}{$A, p, r$} \\State \\Call{Quicksort}{$A, p, q - 1$} \\State \\Call{Quicksort}{$A, q + 1, r$} \\EndIf \\EndProcedure \\Procedure{Partition}{$A, p, r$} \\State $x = A[r]$ \\State $i = p - 1$ \\For{$j = p$ \\bfseries{to} $r - 1$} \\If{$A[j] &lt; x$} \\State $i = i + 1$ \\State exchange $A[i]$ with $A[j]$ \\EndIf \\State exchange $A[i]$ with $A[r]$ \\EndFor \\EndProcedure \\end{algorithmic} \\end{algorithm}\n\n\nCool, right?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Extra</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Halim, Steven, and Felix Halim. 2018. Competitive Programming 4 -\nBook 1. https://cpbook.net.\n\n\n———. 2020. Competitive Programming 4 - Book 2. https://cpbook.net.\n\n\nLaaksonen, Antti. 2020. Guide to Competitive Programming - Learning\nand Improving Algorithms Through Contests. 2nd ed. Springer.\n\n\nSannemo, Johan. 2020. Algorithmic Problem Solving. https://jsannemo.se/aps.pdf.",
    "crumbs": [
      "References"
    ]
  }
]